"use strict";(self.webpackChunklearn=self.webpackChunklearn||[]).push([[7101],{184:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"developer-guides/smart-contracts/write-deploy","title":"Write and Deploy a Contract","description":"At Rubix, smart contracts can be written in languages that compile to WebAssembly, such as Rust and C/C++, and then executed on a blockchain platform that supports WASM. Here are the steps in executing WASM in Rubix.","source":"@site/docs/developer-guides/smart-contracts/write-deploy.md","sourceDirName":"developer-guides/smart-contracts","slug":"/developer-guides/smart-contracts/write-deploy","permalink":"/docs/developer-guides/smart-contracts/write-deploy","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Write and Deploy a Contract","sidebar_label":"Write and Deploy a Contract"},"sidebar":"docs","previous":{"title":"Smart Contract Overview","permalink":"/docs/developer-guides/smart-contracts/overview"},"next":{"title":"Example Smart Contracts","permalink":"/docs/developer-guides/smart-contracts/examples"}}');var o=n(4848),r=n(8453);const c={title:"Write and Deploy a Contract",sidebar_label:"Write and Deploy a Contract"},s="Write and Deploy a Contract",i={},l=[{value:"1. Writing Smart Contracts",id:"1-writing-smart-contracts",level:2},{value:"2. Compiling to WebAssembly",id:"2-compiling-to-webassembly",level:2},{value:"About Generate Smart Contract",id:"about-generate-smart-contract",level:3},{value:"GenerateContract",id:"generatecontract",level:4},{value:"3. Deployment on Blockchain",id:"3-deployment-on-blockchain",level:2},{value:"About Deploy and Subscribe Contract",id:"about-deploy-and-subscribe-contract",level:3},{value:"DeployContract",id:"deploycontract",level:4},{value:"SubscribeContract",id:"subscribecontract",level:4},{value:"4. Execution",id:"4-execution",level:2},{value:"About Execute Contract",id:"about-execute-contract",level:3},{value:"ExecuteContract",id:"executecontract",level:4},{value:"5. Validation",id:"5-validation",level:2},{value:"About Publish Contract",id:"about-publish-contract",level:3},{value:"PublishContract",id:"publishcontract",level:4},{value:"6. State Changes and Output",id:"6-state-changes-and-output",level:2},{value:"7. Immutable Execution",id:"7-immutable-execution",level:2}];function d(e){const t={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"write-and-deploy-a-contract",children:"Write and Deploy a Contract"})}),"\n",(0,o.jsx)(t.p,{children:"At Rubix, smart contracts can be written in languages that compile to WebAssembly, such as Rust and C/C++, and then executed on a blockchain platform that supports WASM. Here are the steps in executing WASM in Rubix."}),"\n",(0,o.jsx)(t.h2,{id:"1-writing-smart-contracts",children:"1. Writing Smart Contracts"}),"\n",(0,o.jsx)(t.p,{children:"Smart contracts are written in high-level programming languages like Rust, GoLang or C/C++. These languages offer the flexibility and expressive power of high-level languages while compiling down to WebAssembly bytecode."}),"\n",(0,o.jsx)(t.h2,{id:"2-compiling-to-webassembly",children:"2. Compiling to WebAssembly"}),"\n",(0,o.jsxs)(t.p,{children:["Once the smart contract code is written, it is compiled to WebAssembly bytecode. Compilers like ",(0,o.jsx)(t.code,{children:"rustc"})," for Rust or Emscripten for C/C++ can be used to generate WebAssembly binaries from the source code."]}),"\n",(0,o.jsx)(t.h3,{id:"about-generate-smart-contract",children:"About Generate Smart Contract"}),"\n",(0,o.jsx)(t.h4,{id:"generatecontract",children:"GenerateContract"}),"\n",(0,o.jsxs)(t.p,{children:["The first step after generating the WASM binaries is to create a Smart Contract Token (programmable NFTs) that is used to track the proof of execution of the contract. The unique Token ID generated is shared by the owner to peer nodes to participate in contract operations.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Sample API:"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"curl --location 'http://localhost:20000/api/generate-smart-contract' --form 'did=\"User DID\"' --form 'binaryCodePath=@\"<Path to your .wasm file>\"' --form 'rawCodePath=@\"<Path to the code compiled to wasm>\"' --form 'schemaFilePath=@\"<Path to the schema or state update file>\"'\n"})}),"\n",(0,o.jsx)(t.h2,{id:"3-deployment-on-blockchain",children:"3. Deployment on Blockchain"}),"\n",(0,o.jsx)(t.p,{children:"The compiled WebAssembly code is then deployed onto a blockchain platform. The contract code, along with any necessary metadata, is stored on the blockchain."}),"\n",(0,o.jsx)(t.h3,{id:"about-deploy-and-subscribe-contract",children:"About Deploy and Subscribe Contract"}),"\n",(0,o.jsx)(t.h4,{id:"deploycontract",children:"DeployContract"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"Generate"})," is an offline setup event that happens before a contract enters the network. Once a SmartContractID is created, the owner deploys the contract to the Rubix network by calling ",(0,o.jsx)(t.code,{children:"deployContract"}),". This creates the first element in the tokenchain and pledges the genesis state of the token.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Sample API:"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'curl --location \'http://localhost:20000/api/deploy-smart-contract\' --header \'Content-Type: application/json\' --data \'{\n  "comment": "Your input Comment",\n  "deployerAddr": "DID of the user who is deploying the smart contract",\n  "quorumType": 2,\n  "rbtAmount": 1,\n  "smartContractToken": "The smart contract tokenID generated in generate-smart-contract api"\n}\'\n'})}),"\n",(0,o.jsx)(t.h4,{id:"subscribecontract",children:"SubscribeContract"}),"\n",(0,o.jsxs)(t.p,{children:["Nodes can subscribe to contract events using the ",(0,o.jsx)(t.code,{children:"subscribe"})," command. This keeps them in sync with contract state changes.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Sample API:"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"curl --location 'http://localhost:20000/api/subscribe-smart-contract' --header 'Content-Type: application/json' --data '{\n  \"smartContractToken\": \"smart contract tokenID generated from generate-smart-contract api\"\n}'\n"})}),"\n",(0,o.jsx)(t.h2,{id:"4-execution",children:"4. Execution"}),"\n",(0,o.jsx)(t.p,{children:"When a user or another contract interacts with the deployed smart contract, the contract\u2019s functions are called via transactions. These transactions contain input data that specifies which function of the contract to execute and with what parameters."}),"\n",(0,o.jsx)(t.h3,{id:"about-execute-contract",children:"About Execute Contract"}),"\n",(0,o.jsx)(t.h4,{id:"executecontract",children:"ExecuteContract"}),"\n",(0,o.jsxs)(t.p,{children:["Nodes that want to execute a contract call this API with details on which function they want to run and the corresponding input parameters. Every smart contract will have a schema file that lists all available function names and data types of parameters.",(0,o.jsx)(t.br,{}),"\n",(0,o.jsx)(t.strong,{children:"Sample API:"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'curl --location \'http://localhost:20000/api/execute-smart-contract\' --header \'Content-Type: application/json\' --data \'{\n  "comment": "Your input Comment",\n  "executorAddr": "DID of the user executing the smart contract",\n  "quorumType": 2,\n  "smartContractData": "Smart contract input which should be written to the token chain",\n  "smartContractToken": "The smart contract token hash generated to which the node has subscribed"\n}\'\n'})}),"\n",(0,o.jsx)(t.h2,{id:"5-validation",children:"5. Validation"}),"\n",(0,o.jsx)(t.p,{children:"The transaction is validated by the blockchain nodes to ensure it follows the rules of the blockchain protocol. Once validated, the transaction and the associated smart contract function call are processed by the nodes."}),"\n",(0,o.jsx)(t.h3,{id:"about-publish-contract",children:"About Publish Contract"}),"\n",(0,o.jsx)(t.h4,{id:"publishcontract",children:"PublishContract"}),"\n",(0,o.jsxs)(t.p,{children:["Once ",(0,o.jsx)(t.code,{children:"executeContract"})," state change is approved via consensus, the node who initiated the state change calls ",(0,o.jsx)(t.code,{children:"publishContract"})," to publish the state update to all peers. ",(0,o.jsx)(t.code,{children:"ExecuteContract"})," and ",(0,o.jsx)(t.code,{children:"DeployContract"})," are always followed by the ",(0,o.jsx)(t.code,{children:"PublishContract"})," API."]}),"\n",(0,o.jsx)(t.h2,{id:"6-state-changes-and-output",children:"6. State Changes and Output"}),"\n",(0,o.jsx)(t.p,{children:"Smart contracts can read data from the blockchain\u2019s state and modify it as per the logic defined in their functions. They can also produce output data, typically returned to the caller after execution."}),"\n",(0,o.jsxs)(t.p,{children:["The smart contract is executed on the DApp side. The DApp should have an API endpoint, which must be passed as a parameter to the ",(0,o.jsx)(t.code,{children:"register-callback-url"})," API. This API registers the endpoint in the node. Once registered, each time an execution happens on the token chain, the states in all subscribed nodes are updated as per the contract logic."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"Sample API:"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'curl --location \'http://localhost:20000/api/register-callback-url\' --header \'Content-Type: application/json\' --data \'{\n  "CallBackURL": "API endpoint url defined on the dapp side",\n  "SmartContractToken": "The smart contract hash generated"\n}\'\n'})}),"\n",(0,o.jsx)(t.h2,{id:"7-immutable-execution",children:"7. Immutable Execution"}),"\n",(0,o.jsx)(t.p,{children:"Once deployed, the logic of a smart contract, represented by its WebAssembly bytecode, is immutable. This means it cannot be changed. If you need to update the contract\u2019s logic, a new version of the contract needs to be deployed."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>s});var a=n(6540);const o={},r=a.createContext(o);function c(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);