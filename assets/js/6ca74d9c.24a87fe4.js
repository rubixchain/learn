"use strict";(self.webpackChunklearn=self.webpackChunklearn||[]).push([[4054],{8032:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"validator-resources/lightweight-node","title":"Setting Up a Lightweight Validator Node","description":"The RubiX Proof of Pledge (PoP) consensus mechanism is designed to be lightweight and distributed. It doesn\'t require energy-intensive mining or large-scale staking. This means that even basic computing nodes can act as validators. The sharded approach, where each validator only stores and maintains tokens for transactions they have validated, significantly reduces the required storage, computational load, and pledge amounts.","source":"@site/docs/validator-resources/lightweight-node.md","sourceDirName":"validator-resources","slug":"/validator-resources/lightweight-node","permalink":"/docs/validator-resources/lightweight-node","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Setting Up a Lightweight Validator Node","sidebar_label":"Setting Up a Lightweight Validator Node"},"sidebar":"docs","previous":{"title":"Become a Validator","permalink":"/docs/validator-resources/become-validator"},"next":{"title":"Tokenchain Validation Process","permalink":"/docs/validator-resources/validation-process"}}');var i=a(4848),o=a(8453);const r={title:"Setting Up a Lightweight Validator Node",sidebar_label:"Setting Up a Lightweight Validator Node"},s="Setting Up a Lightweight Validator Node",d={},l=[];function c(e){const t={h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"setting-up-a-lightweight-validator-node",children:"Setting Up a Lightweight Validator Node"})}),"\n",(0,i.jsx)(t.p,{children:"The RubiX Proof of Pledge (PoP) consensus mechanism is designed to be lightweight and distributed. It doesn't require energy-intensive mining or large-scale staking. This means that even basic computing nodes can act as validators. The sharded approach, where each validator only stores and maintains tokens for transactions they have validated, significantly reduces the required storage, computational load, and pledge amounts."}),"\n",(0,i.jsx)(t.p,{children:"To get started, a validator needs to perform a few key steps:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Run a RubiX node: The foundation of being a validator is running an active node on the network."}),"\n",(0,i.jsx)(t.li,{children:"Generate a Decentralized Identity (DID): Each node needs to have a unique Decentralized Identity to participate."}),"\n",(0,i.jsx)(t.li,{children:"Secure tokens for pledging: You must have RBT tokens available to pledge as collateral."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>s});var n=a(6540);const i={},o=n.createContext(i);function r(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);